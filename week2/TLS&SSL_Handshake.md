# TSL과 SSL Handshake

## SSL과 TSL

- SSL(Secure Sockets Layer)은 암호화 기반 인터넷 프로토콜.
- 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 Netscape가 1995년 처음으로 개발.
- SSL/TLS를 사용하는 웹사이트는 HTTP 대신에 HTTPS를 사용한다.
<img width="500" alt="image" src="https://github.com/do-sopt-cs-study/CS-seungyeon/assets/49530253/97fc3327-4319-4141-a888-b0d8b09f7673">

- 웹에서 전송되는 데이터를 암호화한다. 데이터가 유출되었을 시에 암호화된 데이터만 유출이 된다.
    - 두 통신 장치 사이에 handshake라는 인증 프로세스를 시작해서 두 장치의 ID를 확인.
    - 데이터 무결성을 제공하기 위해 데이터에 디지털 서명하여 데이터 수신자가 조작되지 않은 데이터를 받았다는 것을 확인.
    - 기존에는 메시지가 암호화되지 않았기 때문에 웹 상의 데이터를 누군가 가로챈다면 누구나 읽을 수 있는 평문 데이터였다. 이 문제를 바로잡기 위해서 SSL 제작됨.
    - 사용자 데이터를 탈취하기 위해서 가짜 웹사이트를 만드는 경우가 있는데, SSL가 웹 서버를 인증하기 때문에 이런 공격을 막을 수 있다.
    - 데이터 전송 중간에 데이터를 조작하지 못하도록 막는다.
- TSL의 이전 버전이 SSL. 1999년 IETF(Internet Engineering Task Force)가 SSL 업데이트를 제안하게 되고 Netscape에서 더이상 참여하지 않게 되면서 이름이 TSL로 바뀌었다.
- 둘은 밀접한 관계가 있기 떄문에 혼합되어 사용되는 경우가 많다.TSL을 SSL로 부르기도 하고 SSL/TLS 암호화라고 부르는 경우도 있음.
    - SSL은 TSL 등장 이후 업데이트 되고 있지 않기에 여러 취약성이 있다. 보안 전문가들은 SSL 사용 중단하기를 권고. 실제로 최신 웹 브라우저는 대부분 SSL을 지원하지 않음.
    - TLS는 최신 암호화 프로토콜. 거의 20년 동안 업계 표준. 다만 용어를 혼용해서 쓰는 경우가 있기에 SSL 제공 업체도 사실상 요즘은 TSL을 제공하는 것.

즉, SSL/TSL는 서버, 애플리케이션, 사용자 및 시스템 간의 데이터를 암호화하는 통신 프로토콜. OSI 7계층 중에서 어떤 계층에 속해서 동작하는 게 아니고 응용계층과 전송계층 사이에서 독립적인 프로토콜 계층을 만들어서 동작한다.

<img width="500" alt="image" src="https://github.com/do-sopt-cs-study/CS-seungyeon/assets/49530253/c085901d-902e-428a-91f7-e54fb2fd6348">

네트워크를 통해 연결된 두 당사자를 인증하므로 데이터를 안전하게 교환할 수 있다. handshake 프로세스를 용이하게 하고, 브라우저와 웹 서버 간에 암호화된 통신을 설정하는 디지털 인증서를 사용한다.

## SSL/TLS Handshake

SSL은 대칭키 방식과 비대칭키 방식(공개키)을 섞어서 사용한다.
1. A가 B로 접속 요청을 보낸다.
2. B는 A에게 자신의 공개키를 전송한다. B는 공개키와 개인키를 모두 가지고 있다. 암호화할 때는 공개키, 복호화할 때는 개인키
3. A는 자신의 대칭키를 B에서 받은 공개키로 암호화. 이렇게 암호화한 대칭키를 B에게 전달
4. B는 자신의 개인 키로 복호화하여 A의 대칭키를 알아낸다. 이렇게 A와 B 모두 대칭키 방식에서 쓰이는 공개키를 공유할 수 있게 된다.
5. 이 대칭키를 활용해서 A와 B는 안전하게 통신한다.

즉, 대칭키 방식에서 공개키를 안전하게 공유하기 위해 비대칭키 방식을 사용하고 대칭키 방식으로 통신한다.

TLS Handshake의 단계는 다음과 같습니다.
1. `client`가 `hello` 메시지를 보냅니다. 이때 메시지에는 client가 지원하는 TLS 버전, 지원되는 암호 제품군, 클라이언트 무작위(무작위 바이트 문자열)가 포함됩니다.
2. `client`가 보낸 메시지의 응답으로 `server`도 메시지를 전송합니다. 서버의 SSL 인증서, 서버에서 선택한 암호 제품군, 서버 무작위(무작위 바이트 문자열)가 포함됩니다.
3. `client`가 `server`의 SSL 인증서를 인증서 발행 기관을 통해 검증합니다.
4. `client`는 예비 마스터 암호(무작위 바이트 문자열)를 공개키로 암호화해서 전송합니다. 이는 서버가 가진 개인키로만 복호화할 수 있습니다. `client`는 `server`의 SSL 인증서를 통해 공개키를 알 수 있습니다.
5. `server`가 개인키를 사용하여 복호화합니다.
6. `client`와 `server`가 클라이언트 무작위, 서버 무작위, 예비 마스터 암호를 이용해서 `세션 키`를 생성합니다. 이렇게 둘은 같은 키를 가집니다.
7. `client`는 `세션 키`로 암호화된 `완료` 메시지를 전송합니다.
8. `server`도 `세션 키`로 암호화된 `완료` 메시지를 전송합니다.
9. handshake가 완료됩니다. 통신이 계속 진행됩니다.

<img width="616" alt="image" src="https://github.com/do-sopt-cs-study/CS-seungyeon/assets/49530253/a12cdf09-5d73-49d8-80ef-5f0c1ed3368c">

즉, 일단 클라이언트가 서버를 검증하기 위해 메시지를 주고 받는데 이때 각각의 무작위 문자열을 공유하고 클라이언트는 서버의 공개키를 알게 됩니다.
클라이언트 무작위 문자열, 서버 무작위 문자열, 서버의 공캐기 이 세 가지를 통해 대칭키를 만듭니다.
이 대칭키로 암호화해서 클라이언트와 서버는 한번 더 메시지를 주고 받습니다.
그리고 handshake 끝!

### 사용자가 접속한 사이트가 유효한 사이트인지 확인은 어떻게?

1. 사이트에서 인증기관에게 사이트 정보와 사이트 공개키를 전달한다.
2. 인증기관에는 사이트 인증서를 발급하기 전에 받은 사이트 정보와 사이트 공개키를 검증합니다.
3. 인증기관에서 성공적으로 검증하면, 인증기관에서 인증서를 발급하기 위해 받은 데이터(사이트 정보와 사이트 공개키)를 자신의 개인키로 서명합니다.
4. 인증서를 생성하고 이를 사이트에게 전달한다.
5. 인증기관은 사용자에게 자신의 공개키를 전달한다. 이때 전송한 공개키는 사용자 브라우저에 자동으로 내장됩니다.

여기까지는 사용자가 사이트 접속하기 전

6. 사용자가 사이트 접속을 요청한다.
7. 사이트는 자신이 신뢰할 수 있는 사이트임을 증명하기 위해 사용자에게 인증서를 전송한다.
8. 사용자는 자신이 가지고 있는 인증기관 공개키(브라우저에 내장)로 사이트 인증서를 복호화해서 검증한다. 사용자는 복호화를 성공적으로 마무리하면 사이트 정보와 사이트 공개키를 가질 수 있다.
9. 이렇게 얻은 사이트 공개키로 사용자는 자신의 대칭키를 암호화합니다. 사용자는 암호화한 대칭키를 사이트에게 전송합니다.
10. 사이트는 자신의 개인키로 사용자로부터 전달받은 암호문을 복호화해서 대칭키를 얻습니다.
11. 이후에 대칭키를 사용해서 SSL 통신을 한다.
