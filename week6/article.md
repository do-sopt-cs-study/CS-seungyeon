## 레이스 컨디션
두 개 이상의 프로세스 혹은 스레드가 공유 자원을 서로 사용하려고 경합하는 현상

## Deadlock (교착 상태)

둘 이상의 프로세스 혹은 스레드가 한정된 자원을 얻지 못해 다음 일을 진행하지 못하는 상태
예를 들어 DB transaction Deadlock

Deadlock의 발생 조건은 아래의 4가지이다. 네가지 조건을 모두 만족하면 교착 상태가 발생한다.

1. 상호 배제
  - 하나의 공유자원에 두개의 프로세스가 동시에 접근할 수 없음
2. 점유 대기
  - 프로세스가 특정 자원을 얻기 위해서는 요청을 하고 대기를 해야함
3. 비선점
  - 특정 프로세스가 자원 사용이 끝나기 전까지는 다른 프로세스가 자원을 뺏을 수 없음
4. 순환 대기
  - 프로세스들이 서로 사용하는 자원에 대해서 순환적으로 대기하고 있음

## Deadlock의 해결방법

1. Deadlock 예방
  - 4가지 발생 조건 중 하나를 제거해서 예방함
  - 자원 사용의 효율성이 떨어지고 비용이 많이 듦
    - 상호 배제 조건 제거하면 여러 프로세스가 하나의 공유 자원을 동시에 접근할 수 있다. 현실적 어려움
    - 점유 대기 조건 제거하면 효율성이 매우 떨어짐. 프로세스들이 주기적으로 어떤 자원을 원하는지 파악해야 함.
    - 비선점 조건 제거하면 프로세스가 지금까지 얼마나 작업했는지 알아야한다는 단점.

2. Deadlock 회피
  - 발생 가능성을 파악해서 발생 가능성이 있다면 사전에 회피하는 방식
    - 자원을 요청할 때마다 자원을 할당해도 되는지 판단하고 할당 가능하다고 판단하면 할당하고 그렇지 않으면 다른 프로세스가 자원을 해지할 때까지 대기한다.
    - 자원을 요청할 때마다 시스템 상태를 검사해야하는 오버헤드 발생.

3. Deadlock 탐지 및 회복
  - 가장 많이 쓰임.
  - 교착 상태를 허용하지만 상태를 탐지하고 회복함. 알고리즘을 주기적으로 실행하여 Deadlock 체크. 교착상태 일으킨 프로세스를 종료하거나 할당된 자원을 해제함.

4. Deadlock 무시
   - 교착 상태를 무시함. 이를 예방하거나 회복하는 오버헤드보다 무시하는 게 낫다고 판단.
   - 교착 상태 발생 확률 낮을 때 사용

## 세마포어(Semaphore)

- 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌
- 동기화 대상이 하나 이상
- 세마포어의 카운트를 조절하여 진입 가능한 프로세스/스레드 수를 조절. 이때 세마포어의 카운트는 1 이상.
- 데드락에 대한 고전적인 해결 방법. 모든 교착 상태에 대한 해결 방법은 아니나 대다수의 운영체제에서 언급되는 해결법.
- 상호배제 알고리즘에 기반.

## 뮤텍스(Mutex)

- 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌
- 동기화 대상이 하나
- 한 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법. Key에 해당하는 객체가 있으며, 이 객체를 소유한 스레드/프로세스만이 공유자원에 접근

![image](https://github.com/do-sopt-cs-study/CS-seungyeon/assets/49530253/ef3d93be-f4c8-4704-ade4-f21daebb0c9b)
